/*===========================================================================
    C++ class definitions exported from UnrealScript.
    This is automatically generated by the tools.
    DO NOT modify this manually! Edit the corresponding .uc files instead!
===========================================================================*/
#if ((_MSC_VER) || (HAVE_PRAGMA_PACK))
#pragma pack (push,OBJECT_ALIGNMENT)
#endif

#ifndef IPDRV_API
#define IPDRV_API DLL_IMPORT
#endif

#ifndef NAMES_ONLY
#define AUTOGENERATE_NAME(name) extern IPDRV_API FName IPDRV_##name;
#define AUTOGENERATE_FUNCTION(cls,idx,name)
#endif

AUTOGENERATE_NAME(Accepted)
AUTOGENERATE_NAME(Closed)
AUTOGENERATE_NAME(Opened)
AUTOGENERATE_NAME(ReceivedBinary)
AUTOGENERATE_NAME(ReceivedLine)
AUTOGENERATE_NAME(ReceivedText)
AUTOGENERATE_NAME(Resolved)
AUTOGENERATE_NAME(ResolveFailed)

#ifndef NAMES_ONLY

enum ELinkMode : BYTE
{
	MODE_Text,
	MODE_Line,
	MODE_Binary,
	MODE_MAX,
};
enum EReceiveMode : BYTE
{
	RMODE_Manual,
	RMODE_Event,
	RMODE_MAX,
};
enum ETextEncoding : BYTE
{
	TEXTENC_OS,
	TEXTENC_Truncate,
	TEXTENC_UTF16,
	TEXTENC_MAX,
};
enum ELinkState : BYTE
{
	STATE_Initialized,
	STATE_Ready,
	STATE_Listening,
	STATE_Connecting,
	STATE_Connected,
	STATE_ListenClosePending,
	STATE_ConnectClosePending,
	STATE_ListenClosing,
	STATE_ConnectClosing,
	STATE_MAX,
};

class IPDRV_API AInternetLink : public AInternetInfo
{
public:
	INT Port GCC_PACK(INT_ALIGNMENT);
	INT DataPending;
	SOCKET Socket;
	SOCKET RemoteSocket;
	class FResolveInfo* PrivateResolveInfo;
	BYTE LinkMode;
	BYTE ReceiveMode;
	BYTE TextEncoding;
	DECLARE_FUNCTION(execSendDriverMessage);
	DECLARE_FUNCTION(execIsLocalIpAddr);
	DECLARE_FUNCTION(execGetLocalIP);
	DECLARE_FUNCTION(execValidate);
	DECLARE_FUNCTION(execIpAddrToString);
	DECLARE_FUNCTION(execGetLastError);
	DECLARE_FUNCTION(execResolve);
	DECLARE_FUNCTION(execParseURL);
	DECLARE_FUNCTION(execIsDataPending);
	void eventResolveFailed()
	{
		ProcessEvent(FindFunctionChecked(IPDRV_ResolveFailed),NULL);
	}
	void eventResolved(FIpAddr Addr)
	{
		ProcessEvent(FindFunctionChecked(IPDRV_Resolved),&Addr);
	}
	DECLARE_CLASS(AInternetLink,AInternetInfo,CLASS_Transient,IpDrv)
	#include "AInternetLink.h"
};

class IPDRV_API ATcpLink : public AInternetLink
{
public:
	class UClass* AcceptClass GCC_PACK(INT_ALIGNMENT);
	TArrayNoInit<BYTE> SendFIFO;
	FIpAddr RemoteAddr;
	BYTE LinkState;
	DECLARE_FUNCTION(execReadBinary);
	DECLARE_FUNCTION(execReadText);
	DECLARE_FUNCTION(execSendBinary);
	DECLARE_FUNCTION(execSendText);
	DECLARE_FUNCTION(execIsConnected);
	DECLARE_FUNCTION(execClose);
	DECLARE_FUNCTION(execOpen);
	DECLARE_FUNCTION(execListen);
	DECLARE_FUNCTION(execBindPort);
	void eventReceivedBinary(INT Count, BYTE* B)
	{
		struct { INT Count; BYTE B[255]; } Parms;
		Parms.Count=Count;
		appMemcpy(Parms.B,B,sizeof(Parms.B));
		ProcessEvent(FindFunctionChecked(IPDRV_ReceivedBinary),&Parms);
	}
	void eventReceivedLine(const FString& Line)
	{
		ProcessEvent(FindFunctionChecked(IPDRV_ReceivedLine),const_cast<FString*>(&Line));
	}
	void eventReceivedText(const FString& Text)
	{
		ProcessEvent(FindFunctionChecked(IPDRV_ReceivedText),const_cast<FString*>(&Text));
	}
	void eventClosed()
	{
		ProcessEvent(FindFunctionChecked(IPDRV_Closed),NULL);
	}
	void eventOpened()
	{
		ProcessEvent(FindFunctionChecked(IPDRV_Opened),NULL);
	}
	void eventAccepted()
	{
		ProcessEvent(FindFunctionChecked(IPDRV_Accepted),NULL);
	}
	DECLARE_CLASS(ATcpLink,AInternetLink,CLASS_Transient,IpDrv)
	#include "ATcpLink.h"
};

class IPDRV_API AUdpLink : public AInternetLink
{
public:
	INT BroadcastAddr GCC_PACK(INT_ALIGNMENT);
	DECLARE_FUNCTION(execReadBinary);
	DECLARE_FUNCTION(execReadText);
	DECLARE_FUNCTION(execSendBinary);
	DECLARE_FUNCTION(execSendText);
	DECLARE_FUNCTION(execBindPort);
	void eventReceivedBinary(FIpAddr Addr, INT Count, BYTE* B)
	{
		struct { FIpAddr Addr; INT Count; BYTE B[255]; } Parms;
		Parms.Addr=Addr;
		Parms.Count=Count;
		appMemcpy(Parms.B,B,sizeof(Parms.B));
		ProcessEvent(FindFunctionChecked(IPDRV_ReceivedBinary),&Parms);
	}
	void eventReceivedLine(FIpAddr Addr, const FString& Line)
	{
		struct { FIpAddr Addr; FString Line; } Parms = { Addr, Line };
		ProcessEvent(FindFunctionChecked(IPDRV_ReceivedLine),&Parms);
	}
	void eventReceivedText(FIpAddr Addr, const FString& Text)
	{
		struct { FIpAddr Addr; FString Text; } Parms = { Addr, Text };
		ProcessEvent(FindFunctionChecked(IPDRV_ReceivedText),&Parms);
	}
	DECLARE_CLASS(AUdpLink,AInternetLink,CLASS_Transient,IpDrv)
	#include "AUdpLink.h"
};

#endif

AUTOGENERATE_FUNCTION(AInternetLink,-1,execSendDriverMessage);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIsLocalIpAddr);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execGetLocalIP);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execValidate);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIpAddrToString);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execGetLastError);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execResolve);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execParseURL);
AUTOGENERATE_FUNCTION(AInternetLink,-1,execIsDataPending);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execReadBinary);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execReadText);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execSendBinary);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execSendText);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execIsConnected);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execClose);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execOpen);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execListen);
AUTOGENERATE_FUNCTION(ATcpLink,-1,execBindPort);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execReadBinary);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execReadText);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execSendBinary);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execSendText);
AUTOGENERATE_FUNCTION(AUdpLink,-1,execBindPort);

#ifndef NAMES_ONLY
#undef AUTOGENERATE_NAME
#undef AUTOGENERATE_FUNCTION
#endif // NAMES_ONLY

#if ((_MSC_VER) || (HAVE_PRAGMA_PACK))
#pragma pack (pop)
#endif

#ifdef VERIFY_CLASS_SIZES
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,Port)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,DataPending)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,Socket)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,RemoteSocket)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,PrivateResolveInfo)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,LinkMode)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,ReceiveMode)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,InternetLink,TextEncoding)
VERIFY_CLASS_SIZE_NODIE(AInternetLink)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,TcpLink,AcceptClass)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,TcpLink,SendFIFO)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,TcpLink,RemoteAddr)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,TcpLink,LinkState)
VERIFY_CLASS_SIZE_NODIE(ATcpLink)
VERIFY_CLASS_OFFSET_NODIE_SLOW(A,UdpLink,BroadcastAddr)
VERIFY_CLASS_SIZE_NODIE(AUdpLink)
#endif // VERIFY_CLASS_SIZES
